<div>
    <div class="flow-preview">
        <svg>
            <g class="flow-preview-grid"></g>
            <g class="flow-preview-wires"></g>
            <g class="flow-preview-nodes"></g>
        </svg>
    </div>
    <div class="flowviewer">
        <svg>
            <g class="flowGridlines"></g>
            <g class="containerGroup"></g>
            <g class="flowGroups"></g>
            <g class="flowWires"></g>
            <g class="flowNodes"></g>
        </svg>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js" integrity="sha512-M7nHCiNUOwFt6Us3r8alutZLm9qMt4s9951uo8jqO4UwJ1hziseL6O3ndFyigx6+LREfZqnhHxYjKRJ8ZQ69DQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js" integrity="sha512-M7nHCiNUOwFt6Us3r8alutZLm9qMt4s9951uo8jqO4UwJ1hziseL6O3ndFyigx6+LREfZqnhHxYjKRJ8ZQ69DQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<head>
    <script type="text/javascript" src="/js/flowviewer.js"></script>
</head>
<script type="text/javascript">
    (function () {
        const flow = {{{flow}}}
        console.log(flow)
        console.log($('.flowviewer svg'))
        renderFlow("46186ccb85f93a93", flow, $('.flowviewer svg'), { 
            gridlines: true, 
            images: true, 
            linklines: true 
        });
    })()
</script>

<script>
    (function () {

        const SPACE_WIDTH = 5000,
            SPACE_HEIGHT = 5000,
            lineCurveScale = 0.75,
            scaleFactor = 1,
            NODE_WIDTH = 100,
            NODE_HEIGHT = 30,
            PORT_WIDTH = 10

        const GRID_SIZE = 20;

        const flow = {{{flow}}}
        console.log(flow)
        
        const svg = d3.select('.flow-preview svg')

        // draw grid
        gridLayer = svg.select('.flow-preview-grid')
        updateGrid()

        // draw nodes
        nodesLayer = svg.select('.flow-preview-nodes')
        wiresLayer = svg.select('.flow-preview-wires')
        drawFlow(flow)

        function updateGrid() {
            var gridTicks = [];
            for (var i=0; i < SPACE_WIDTH; i +=+ GRID_SIZE) {
                gridTicks.push(i);
            }
            gridLayer.selectAll("line.flow-preview-grid-h").remove();
            gridLayer.selectAll("line.flow-preview-grid-h")
                .data(gridTicks).enter()
                .append("line")
                .attr("class", "flow-preview-grid-h")
                .attr("x1", 0)
                .attr("x2", SPACE_WIDTH)
                .attr("y1", function(d){ return d; })
                .attr("y2", function(d){ return d; })

            gridLayer.selectAll("line.flow-preview-grid-v").remove();
            gridLayer.selectAll("line.flow-preview-grid-v")
                .data(gridTicks).enter()
                .append("line")
                .attr("class", "flow-preview-grid-h")
                .attr("y1", 0)
                .attr("y2", SPACE_WIDTH)
                .attr("x1", function(d){ return d; })
                .attr("x2", function(d){ return d; })
        }

        function drawFlow (flow) {
            const wires = []
            const nodesWithInput = []

            // get just the data from our flow.json that are rendered in the editor
            const nodes = flow.filter((node) => {
                if (node.wires && node.wires.length > 0) {
                    // push from/to data for a wire so we can draw it later
                    wires.push({
                        from: node.id, 
                        to: node.wires[0][0]
                    })
                    // record array of ids with inputs for easier rendering later
                    nodesWithInput.push(node.wires[0][0])
                    node._outputs = node.wires.length
                }
                // check node has x and y properties
                return node.hasOwnProperty('x') && node.hasOwnProperty('y')
            })

            // pre-process the nodes and add some helper counts for us to draw the flow
            for (const n in nodes) {
                if (nodesWithInput.includes(nodes[n].id)) {
                    nodes[n]._inputs = 1
                }
            }

            // clear canvas
            nodesLayer.selectAll('g.flow-preview-node').remove()
            // draw nodes
            const g = nodesLayer.selectAll('g.flow-preview-node')
                .data(nodes).enter()
                .append('g')
                .attr('transform', function (node) {
                    return 'translate(' + node.x + ',' + node.y + ')'
                })
            
            // base node shape
            var base = g.append('rect')
                .attr("class", "flow-preview-node-base")
                .attr("rx", 5)
                .attr("ry", 5)
                .attr("height", NODE_HEIGHT)
                .attr("data-node-id", function (node) {
                    return node.id
                })

            // base node icon
            g.append('rect')
                .attr("class", "flow-preview-node-icongroup")
                .attr("rx", 5)
                .attr("ry", 5)
                .attr("width", NODE_HEIGHT + 5)
                .attr("height", NODE_HEIGHT)
                .style("clip-path", "inset(0px 5px 0px 0px)")

            // node label
            const label = g.append('g')
                .attr('class', 'flow-preview-node-label')
                .attr('transform', function (node) {
                    const x = (NODE_HEIGHT + 10)
                    const y = (NODE_HEIGHT + 2) / 2
                    return `translate(${x}, ${y})`
                })
            
            const text = label.append('text')
                .text(function (node) {
                    return node.name || node.type
                })

            /*
                nn.w = Math.max(NODE_WIDTH, 20 * (Math.ceil((labelParts.width + 50 + (nn._def.inputs > 0 ? 7 : 0)) / 20 )));
                nn.h = Math.max(6+24*labelParts.lines.length,(nn.outputs || 0) * 15, 30);
            */
            // re-assess the width of the node now that we've rendered the label
            base.attr("width", function (node) {
                    // given the label, how big should this node be?
                    const textWidth = text.node().getBoundingClientRect().width
                    const inputs = node._inputs || 0
                    return Math.max(NODE_WIDTH, 20 * Math.ceil(((inputs > 0 ? 25 : 0) + textWidth + 50) / 20))
                })

            // draw the input/output ports
            const inputs = g.append('g')
                .attr('class', 'flow-preview-node-input')
                .attr('transform', function (node) {
                    return 'translate(' + 0 + ',' + (NODE_HEIGHT / 2) + ')'
                })

            inputs
                .filter((node) => {
                    return node._inputs > 0
                })
                .selectAll('g.flow-preview-node-port')
                .data((node) => {
                    return new Array(node._inputs)
                }).enter()
                .append('g')
                .attr('class', 'flow-preview-node-port')
                .append('rect')
                .attr('width', PORT_WIDTH)
                .attr('height', PORT_WIDTH)
                .attr('rx', 3)
                .attr('ry', 3)
                .attr('transform', function () {
                    return `translate(${-PORT_WIDTH/2}, ${-PORT_WIDTH/2})`
                })

            const outputs = g.append('g')
                .attr('class', 'flow-preview-node-output')
                .attr('transform', function (node) {
                    const x = base.node().getBoundingClientRect().width
                    const y = (NODE_HEIGHT / 2)
                    return `translate(${x}, ${y})`
                })

            outputs
                .filter((node) => {
                    return node.wires.length > 0
                })
                .selectAll('g.flow-preview-node-port')
                .data((node) => {
                    return node.wires
                }).enter()
                .append('g')
                .attr('class', 'flow-preview-node-port')
                .append('rect')
                .attr('width', PORT_WIDTH)
                .attr('height', PORT_WIDTH)
                .attr('rx', 3)
                .attr('ry', 3)
                .attr('transform', function () {
                    return `translate(${-PORT_WIDTH/2}, ${-PORT_WIDTH/2})`
                })

            // clear existing wires
            wiresLayer.selectAll('g.flow-preview-node').remove()

            // draw wires
            wires.forEach((wire) => {
                wire.fromNode = d3.select('rect[data-node-id="' + wire.from + '"]')
                wire.toNode = d3.select('rect[data-node-id="' + wire.to + '"]')
                console.log(wire)
            })
            
            wiresLayer.selectAll('g.flow-preview-wire')
                .data(wires).enter()
                .append('g')
                .append('path')
                .attr('class', 'flow-preview-wire')
                .attr('d', function (wire) {
                    const from = wire.fromNode.data()[0]
                    const to = wire.toNode.data()[0]
                    const fromX = from.x + NODE_WIDTH
                    const fromY = from.y + (NODE_HEIGHT / 2)
                    const toX = to.x
                    const toY = to.y + (NODE_HEIGHT / 2)
                    return generateLinkPath(fromX, fromY, toX, toY, 1, false)
                })

            function generateLinkPath(origX, origY, destX, destY, sc, hasStatus = false) {
                var dy = destY-origY;
                var dx = destX-origX;
                var delta = Math.sqrt(dy*dy+dx*dx);
                var scale = lineCurveScale;
                var scaleY = 0;
                if (dx*sc > 0) {
                    if (delta < NODE_WIDTH) {
                        scale = 0.75-0.75*((NODE_WIDTH - delta) / NODE_WIDTH);
                        // scale += 2*(Math.min(5*NODE_WIDTH,Math.abs(dx))/(5*NODE_WIDTH));
                        // if (Math.abs(dy) < 3*NODE_HEIGHT) {
                        //     scaleY = ((dy>0)?0.5:-0.5)*(((3*NODE_HEIGHT)-Math.abs(dy))/(3*NODE_HEIGHT))*(Math.min(NODE_WIDTH,Math.abs(dx))/(NODE_WIDTH)) ;
                        // }
                    }
                } else {
                    scale = 0.4 - 0.2 *( Math.max(0, (NODE_WIDTH - Math.min(Math.abs(dx), Math.abs(dy))) / NODE_WIDTH));
                }
                function genCP(cp) {
                    return ` M ${cp[0]-5} ${cp[1]} h 10 M ${cp[0]} ${cp[1]-5} v 10 `
                }
                if (dx*sc > 0) {
                    let cp = [
                        [(origX+sc*(NODE_WIDTH*scale)), (origY+scaleY*NODE_HEIGHT)],
                        [(destX-sc*(scale)*NODE_WIDTH), (destY-scaleY*NODE_HEIGHT)]
                    ]
                    return `M ${origX} ${origY} C ${cp[0][0]} ${cp[0][1]} ${cp[1][0]} ${cp[1][1]} ${destX} ${destY}`
                        //    + ` ${genCP(cp[0])} ${genCP(cp[1])}`
                } else {
                    let topX, topY, bottomX, bottomY
                    let cp
                    let midX = Math.floor(destX-dx/2);
                    let midY = Math.floor(destY-dy/2);          
                    if (Math.abs(dy) < 10) {
                        bottomY = Math.max(origY, destY) + (hasStatus?35:25)
                        let startCurveHeight = bottomY - origY
                        let endCurveHeight = bottomY - destY
                        cp = [
                            [ origX + sc*15 , origY ],
                            [ origX + sc*25 , origY + 5 ],
                            [ origX + sc*25 , origY + startCurveHeight/2 ],

                            [ origX + sc*25 , origY + startCurveHeight - 5 ],
                            [ origX + sc*15 , origY + startCurveHeight ],
                            [ origX , origY + startCurveHeight ],

                            [ destX - sc*15, origY + startCurveHeight ],
                            [ destX - sc*25, origY + startCurveHeight - 5 ],
                            [ destX - sc*25, destY + endCurveHeight/2 ],

                            [ destX - sc*25, destY + 5 ],
                            [ destX - sc*15, destY ],
                            [ destX, destY ],
                        ]

                        return "M "+origX+" "+origY+
                            " C "+
                            cp[0][0]+" "+cp[0][1]+" "+
                            cp[1][0]+" "+cp[1][1]+" "+
                            cp[2][0]+" "+cp[2][1]+" "+
                            " C " +
                            cp[3][0]+" "+cp[3][1]+" "+
                            cp[4][0]+" "+cp[4][1]+" "+
                            cp[5][0]+" "+cp[5][1]+" "+
                            " h "+dx+
                            " C "+
                            cp[6][0]+" "+cp[6][1]+" "+
                            cp[7][0]+" "+cp[7][1]+" "+
                            cp[8][0]+" "+cp[8][1]+" "+
                            " C " +
                            cp[9][0]+" "+cp[9][1]+" "+
                            cp[10][0]+" "+cp[10][1]+" "+
                            cp[11][0]+" "+cp[11][1]+" "
                            // +genCP(cp[0])+genCP(cp[1])+genCP(cp[2])+genCP(cp[3])+genCP(cp[4])
                            // +genCP(cp[5])+genCP(cp[6])+genCP(cp[7])+genCP(cp[8])+genCP(cp[9])+genCP(cp[10])
                    } else {
                        var cp_height = NODE_HEIGHT/2;
                        var y1 = (destY + midY)/2
                        topX = origX + sc*NODE_WIDTH*scale;
                        topY = dy>0?Math.min(y1 - dy/2 , origY+cp_height):Math.max(y1 - dy/2 , origY-cp_height);
                        bottomX = destX - sc*NODE_WIDTH*scale;
                        bottomY = dy>0?Math.max(y1, destY-cp_height):Math.min(y1, destY+cp_height);
                        var x1 = (origX+topX)/2;
                        var scy = dy>0?1:-1;
                        cp = [
                            // Orig -> Top
                            [x1,origY],
                            [topX,dy>0?Math.max(origY, topY-cp_height):Math.min(origY, topY+cp_height)],
                            // Top -> Mid
                            // [Mirror previous cp]
                            [x1,dy>0?Math.min(midY, topY+cp_height):Math.max(midY, topY-cp_height)],
                            // Mid -> Bottom
                            // [Mirror previous cp]
                            [bottomX,dy>0?Math.max(midY, bottomY-cp_height):Math.min(midY, bottomY+cp_height)],
                            // Bottom -> Dest
                            // [Mirror previous cp]
                            [(destX+bottomX)/2,destY]
                        ];
                        if (cp[2][1] === topY+scy*cp_height) {
                            if (Math.abs(dy) < cp_height*10) {
                                cp[1][1] = topY-scy*cp_height/2;
                                cp[3][1] = bottomY-scy*cp_height/2;
                            }
                            cp[2][0] = topX;
                        }
                        return "M "+origX+" "+origY+
                            " C "+
                            cp[0][0]+" "+cp[0][1]+" "+
                            cp[1][0]+" "+cp[1][1]+" "+
                            topX+" "+topY+
                            " S "+
                            cp[2][0]+" "+cp[2][1]+" "+
                            midX+" "+midY+
                        " S "+
                            cp[3][0]+" "+cp[3][1]+" "+
                            bottomX+" "+bottomY+
                            " S "+
                                cp[4][0]+" "+cp[4][1]+" "+
                                destX+" "+destY

                        // +genCP(cp[0])+genCP(cp[1])+genCP(cp[2])+genCP(cp[3])+genCP(cp[4])
                    }
                }
            }

        }
    })()
</script>